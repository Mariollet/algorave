<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorave - Visualisations Mathématiques</title>
    <link rel="stylesheet" href="assets/css/algorave.css">
</head>
<body>
    <!-- Canvas pour le bruit de Perlin subtil -->
    <canvas id="perlinCanvas"></canvas>
    
    <!-- Overlay gradient -->
    <div class="gradient-overlay"></div>
    
    <div class="container">
        <div class="header">
            <h1>Algorave</h1>
            <p class="subtitle">collection // fractales & expériences visuelles algorithmiques</p>
        </div>
        
        <div class="gallery">
            <div class="card" onclick="window.location.href='mandelbrot-new.html'">
                <h3>Mandelbrot Set</h3>
                <p>
                    L'ensemble de Mandelbrot classique avec zoom infini 
                    et palettes de couleurs psychédéliques. Mode auto inclus
                    pour une exploration guidée des zones fractales.
                </p>
                <span class="btn">explore →</span>
            </div>
            
            <div class="card special-card" onclick="window.location.href='quantum-kaleidoscope.html'">
                <h3>Quantum Kaleidoscope</h3>
                <p>
                    Expérience visuelle immersive unique. Fractales quantiques 
                    et distorsions temporelles pour une exploration psychédélique 
                    dans l'univers algorithmique.
                </p>
                <span class="btn">execute →</span>
            </div>
        </div>
    </div>

    <script>
        // Générateur de bruit de Perlin minimaliste
        class PerlinNoise {
            constructor() {
                this.permutation = [];
                for (let i = 0; i < 256; i++) {
                    this.permutation[i] = Math.floor(Math.random() * 256);
                }
                this.permutation = this.permutation.concat(this.permutation);
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const A = this.permutation[X] + Y;
                const AA = this.permutation[A];
                const AB = this.permutation[A + 1];
                const B = this.permutation[X + 1] + Y;
                const BA = this.permutation[B];
                const BB = this.permutation[B + 1];

                return this.lerp(v,
                    this.lerp(u, this.grad(this.permutation[AA], x, y),
                        this.grad(this.permutation[BA], x - 1, y)),
                    this.lerp(u, this.grad(this.permutation[AB], x, y - 1),
                        this.grad(this.permutation[BB], x - 1, y - 1))
                );
            }
        }

        // Canvas setup
        const canvas = document.getElementById('perlinCanvas');
        const ctx = canvas.getContext('2d');
        const perlin = new PerlinNoise();
        let time = 0;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function drawPerlinBackground() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let x = 0; x < canvas.width; x += 3) {
                for (let y = 0; y < canvas.height; y += 3) {
                    const noise1 = perlin.noise(x * 0.008 + time * 0.001, y * 0.008);
                    const noise2 = perlin.noise(x * 0.016 + time * 0.002, y * 0.016);
                    const noise3 = perlin.noise(x * 0.032 + time * 0.003, y * 0.032);
                    
                    const combined = (noise1 + noise2 * 0.7 + noise3 * 0.4) / 2.1;
                    const intensity = Math.floor((combined + 1) * 127.5);
                    
                    // Couleurs rave plus intenses
                    const r = Math.max(0, Math.min(255, intensity + Math.sin(time * 0.015) * 40));
                    const g = Math.max(0, Math.min(255, intensity * 0.7 + Math.cos(time * 0.012) * 50));
                    const b = Math.max(0, Math.min(255, intensity + Math.sin(time * 0.018) * 60));
                    
                    for (let dx = 0; dx < 3 && x + dx < canvas.width; dx++) {
                        for (let dy = 0; dy < 3 && y + dy < canvas.height; dy++) {
                            const index = ((y + dy) * canvas.width + (x + dx)) * 4;
                            data[index] = r;
                            data[index + 1] = g;
                            data[index + 2] = b;
                            data[index + 3] = 120; // Alpha beaucoup plus élevé
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function animate() {
            time += 1.5;
            drawPerlinBackground();
            requestAnimationFrame(animate);
        }

        // Initialisation
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        animate();
    </script>
</body>
</html>
